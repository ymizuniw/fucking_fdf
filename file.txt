#include "includes/fdf.h"

//initialize app contents
void	alloc_app_content(t_app *app)
{
    ft_bzero(app, sizeof(*app));
	app->map = malloc(sizeof(t_map));
	if (app->map == NULL)
		perror_exit(MALLOC_FAILURE);
    ft_bzero(app->map, sizeof(*app->map));
	app->mat = malloc(sizeof(t_matrix));
	if (app->mat == NULL)
		free_app(app, "malloc matrix\n");
    ft_bzero(app->mat, sizeof(*app->mat));
    app->mat->scale = 1.0f;
	app->img = malloc(sizeof(t_img));
	if (app->img == NULL)
		free_app(app, "malloc img structure failed\n");
    ft_bzero(app->img, sizeof(*app->img));
    app->option = malloc(sizeof(t_option));
    if (!app->option)
        free_app(app, "malloc option structure failed\n");
    ft_bzero(app->option, sizeof(*app->option));
    app->map->color = 0xFFFFFF;
}
#include "includes/fdf.h"

//termination should be with -1 or other negative num.
static size_t get_map_width(int *int_array)
{
   size_t count;

   count = 0;
   while (int_array[count])
       count++;
   return (count);
}

static size_t get_map_height(t_parse_list *head)
{
   size_t size;

   size = 0;
   while (head)
   {
       size++;
       head = head->next;
   }
   return (size);
}

static void free_and_exit(char *msg, t_app *app, t_parse_list *head)
{
    perror(msg);
    free_parse_list(head);
    free_app(app, msg);
    exit(EXIT_FAILURE);
}

void alloc_maps(t_app *app, t_parse_list *head)
{
    head = head->next;
    if (head == NULL)
        free_and_exit(MALLOC_FAILURE, app, head);
   app->map->width = get_map_width(head->int_array);
   app->map->height = get_map_height(head);
   app->map->map_size = app->map->width * app->map->height;
   app->map->map_3d = malloc(sizeof(t_map_3d) * (app->map->map_size));
   if (!app->map->map_3d)
        free_and_exit(MALLOC_FAILURE, app, head);
    app->map->map_2d = malloc(sizeof(t_map_2d) * (app->map->map_size));
    if (!app->map->map_2d)
        free_and_exit(MALLOC_FAILURE, app, head);
}
#include "includes/fdf.h"

//how to set it correctly.
static void centering_screen(t_map_2d *ptr, t_app *app)
{
    ptr->x += (float)(app->img->img_width * 0.5f) + app->mat->pan_x;
    ptr->y += (float)(app->img->img_height * 0.5f) + app->mat->pan_y;
}

//convert 3d vector to 2d
void	convert_map(t_app *app)
{
	size_t	i;

	i = 0;
	while (i < app->map->map_size)
	{
		app->map->map_2d[i] = convert_points(app->map->map_3d[i], app->mat);
        centering_screen(&app->map->map_2d[i], app);
		app->map->map_2d[i].color = app->map->color;
		i++;
	}
}
#include "includes/fdf.h"

static void	rotate_x(t_map_3d *p, float t)
{
    float tmp_y;
    float tmp_z;

    tmp_y = p->y;
    tmp_z = p->z;
	p->y = tmp_y * cos(t) - tmp_z * sin(t);
	p->z = tmp_y * sin(t) + tmp_z * cos(t);
}

static void	rotate_y(t_map_3d *p, float t)
{
    float tmp_x;
    float tmp_z;

    tmp_x = p->x;
    tmp_z = p->z;
	p->x = tmp_x * cos(t) + tmp_z * sin(t);
	p->z = tmp_x * (-sin(t)) + tmp_z * cos(t);
}

static void	rotate_z(t_map_3d *p, float t)
{
    float tmp_x;
    float tmp_y;

    tmp_x = p->x;
    tmp_y = p->y;
	p->x = tmp_x * (float)cos(t) - tmp_y * (float)sin(t);
	p->y = tmp_x * (float)sin(t) + tmp_y * (float)cos(t);
}

// isometric projection using angle t = 30;
static t_map_2d	proj_iso(t_map_3d p)
{
	t_map_2d res;

	res.x = (p.x - p.y) * COS30;
	res.y = (p.x + p.y) * SIN30 - p.z;
	res.color = 0;
	return (res);
}

//define the point z(x,y) and then,
//call convert_object() for all elements of map_3d
t_map_2d		convert_points(t_map_3d ptr, t_matrix *mat)
{
	t_map_2d	new;

	rotate_z(&ptr, mat->theta_z);
	rotate_y(&ptr, mat->theta_y);
	rotate_x(&ptr, mat->theta_x);
	new = proj_iso(ptr);
	new.x *= mat->scale;
	new.y *= mat->scale;
	return (new);
}
#include "includes/fdf.h"

// static float	round_pi(float theta)
// {
// 	while (theta > PI)
// 		theta -= 2.0f * PI;
// 	while (theta <= -PI)
// 		theta += 2.0f * PI;
// 	return (theta);
// }

// static void	validate_angles(t_app *app)
// {
// 	app->mat->theta_x = round_pi(app->mat->theta_x);
// 	app->mat->theta_y = round_pi(app->mat->theta_y);
// 	app->mat->theta_z = round_pi(app->mat->theta_z);
// }

// void	direction_mono(int key, t_app *app)
// {
// 	if (key == XK_Left)
// 		app->mat->theta_z -= ROT_UNIT;
// 	else if (key == XK_Right)
// 		app->mat->theta_z += ROT_UNIT;
// 	else if (key == XK_Up)
// 		app->mat->theta_x -= ROT_UNIT;
// 	else if (key == XK_Down)
// 		app->mat->theta_x += ROT_UNIT;
// 	validate_angles(app);
// }

t_vec3 get_axis_z(void)
{
	t_vec3 axis;

	axis.x = 0;
	axis.y = 0;
	axis.z = 1;
	return (axis);
}

t_vec3 get_axis_x(void)
{
	t_vec3 axis;

	axis.x = 1;
	axis.y = 0;
	axis.z = 0;
	return (axis);	
}

void direction_mono(int key, t_app *app)
{
    t_vec3 axis_x;
	t_vec3 axis_z;

	axis_x = get_axis_x();
	axis_z = get_axis_z();
    if (key == XK_Left)
        rotation_adjustment(app, axis_z, -ROT_UNIT);
    else if (key == XK_Right)
        rotation_adjustment(app, axis_z, ROT_UNIT);
    else if (key == XK_Up)
        rotation_adjustment(app, axis_x, -ROT_UNIT);
    else if (key == XK_Down) 
        rotation_adjustment(app, axis_x, ROT_UNIT);
}
#include "includes/fdf.h"

// static void	clamp_pan(t_app *app)
// {
// 	app->mat->pan_x = clamp_elem(app->mat->pan_x);
// 	app->mat->pan_y = clamp_elem(app->mat->pan_y);
// }

// void	direction_shift(int key, t_app *app)
// {
// 	if (key == XK_Left && (app->mat->pan_x - PAN_UNIT > -(app->map->width/2)))
// 		app->mat->pan_x -= PAN_UNIT;
// 	else if (key == XK_Right && (app->mat->pan_x + PAN_UNIT < app->map->width/2))
// 		app->mat->pan_x += PAN_UNIT;
// 	else if (key == XK_Up && (app->mat->pan_y - PAN_UNIT > -(app->map->height/2)))
// 		app->mat->pan_y -= PAN_UNIT;
// 	else if (key == XK_Down && (app->mat->pan_y + PAN_UNIT < app->map->height/2))
// 		app->mat->pan_y += PAN_UNIT;
// 	// clamp_pan(app);
// }

void direction_shift(int key, t_app *app)
{
    if (key == XK_Left)        app->mat->pan_x -= PAN_UNIT;
    else if (key == XK_Right)  app->mat->pan_x += PAN_UNIT;
    else if (key == XK_Up)     app->mat->pan_y -= PAN_UNIT;
    else if (key == XK_Down)   app->mat->pan_y += PAN_UNIT;
}
#include "includes/fdf.h"

//mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);
//dst holds the infromation of color of the designated pixel.
static void	put_pixel(t_img *img, int x, int y, int color)
{
	if (x < 0 || x >= img->img_width || y < 0 || y >= img->img_height)
		return ;
	char *dst = img->data_addr + (y * img->size_line + x * (img->bits_per_pixel / 8));
	*(unsigned int *)dst = color;
}

//draw_line function is based on Bresenham's line drawing algorithm.
static void	initialize_draw_line_struct(t_draw_line *dl, t_map_2d *start, t_map_2d *end)
{
	dl->x = (int)start->x;
	dl->y = (int)start->y;
	dl->dx = (int)end->x - (int)start->x;
	dl->dy = (int)end->y - (int)start->y;
	dl->sign_x = 1;
	dl->sign_y = 1;
	if (dl->dx < 0)
	{
		dl->dx *= -1;
		dl->sign_x *= -1;
	}
	if (dl->dy < 0)
	{
		dl->dy *= -1;
		dl->sign_y *= -1;
	}
}

//x major axis bresenham
static	void	x_major_axis(t_draw_line *dl, t_img *img, t_map_2d *start, t_map_2d *end)
{
	int err;
	err = dl->dx / 2;
	while (dl->x != (int)end->x)
	{
		put_pixel(img, dl->x, dl->y, start->color);
		err -= dl->dy;
		if (err < 0)
		{
			dl->y += dl->sign_y;
			err += dl->dx;
		}
		dl->x += dl->sign_x;
	}
}

//y major axis bresenham
static void y_major_axis(t_draw_line *dl, t_img *img, t_map_2d *start, t_map_2d *end)
{
	int err;
	err = dl->dy / 2;
	while (dl->y != (int)end->y)
	{
		put_pixel(img, dl->x, dl->y, start->color);
		err -= dl->dx;
		if (err < 0)
		{
			dl->x += dl->sign_x;
			err += dl->dy;
		}
		dl->y += dl->sign_y;
	}
}

//draw_line() put pixels to img buffer by Bresenham's line algorithm.
//start point and end point are given by t_map_2d struct.
void	draw_line(t_img *img, t_map_2d *start, t_map_2d *end)
{
	t_draw_line dl;

	initialize_draw_line_struct(&dl, start, end);
	if (dl.dx > dl.dy)
		x_major_axis(&dl, img, start, end);
	else
		y_major_axis(&dl, img, start, end);
	put_pixel(img, dl.x, dl.y, start->color);
}
#include "includes/fdf.h"

static void connect_row(t_img *img, t_map_2d *map_2d, size_t map_width, size_t map_height)
{
    size_t y;
    size_t x;

    y = 0;
    while (y < map_height)
    {
        x = 0;
        while (x < map_width - 1)
        {
            draw_line(img, &map_2d[y * map_width + x], &map_2d[y * map_width + x + 1]);
            x++;
        }
        y++;
    }
}

static void connect_column(t_img *img, t_map_2d *map_2d, size_t map_width, size_t map_height)
{
    size_t y;
    size_t x;

    x = 0;
    while (x < map_width)
    {
        y = 0;
        while (y < map_height - 1)
        {
            draw_line(img, &map_2d[y * map_width + x], &map_2d[(y + 1) * map_width + x]);
            y++;
        }
        x++;
    }
}

void draw_map(t_app *app)
{
    connect_row(app->img, app->map->map_2d, app->map->width, app->map->height);
    connect_column(app->img, app->map->map_2d, app->map->width, app->map->height);
}
#include "includes/fdf.h"

void    free_parse_list(t_parse_list *head)
{
    t_parse_list *next;

    while (head)
    {
        next = head->next;
        if (head->int_array)
            free(head->int_array);
        free(head);
        head = next;
    }
}

//free vectors
void free_map(t_app *app)
{
	if (!app || !app->map)
		return ;
	if(app->map->map_2d)
		free(app->map->map_2d);
	if (app->map->map_3d)
		free(app->map->map_3d);
	free(app->map);
}

void	free_app(t_app *app, const char *msg)
{
	if (!app)
		return ;
	if (app->map)
		free_map(app);
	if (app->mat)
		free(app->mat);
	if (app->img)
		free(app->img);
    if (app->option)
		free(app->option);
	ft_putstr_fd(msg, 2);
}

void	free_all_rscs(t_app *app, const char *msg)
{	
	if (app && app->img->img_ptr)
		mlx_destroy_image(app->mlx_ptr, app->img->img_ptr);
	if (app && app->mlx_ptr && app->win_ptr)
		mlx_destroy_window(app->mlx_ptr, app->win_ptr);
	if (app && app->mlx_ptr)
	{
		mlx_destroy_display(app->mlx_ptr);
		free(app->mlx_ptr);
	}
	free_app(app, msg);
}

void free_all_rscs_exit(t_app *app, int status)
{
	free_all_rscs(app, "\n");
	exit(status);
}
#include "includes/fdf.h"

static size_t	count_elem(char *s)
{
	size_t	i;
	size_t	j;
	size_t	count;

	i = 0;
	j = 0;
	count = 0;
	while (s[i] && s[i] != '\n')
	{
		while (s[i] && s[i] == ' ')
			i++;
		if (!s[i] || s[i] == '\n')
			break ;
		if (s[i] == '+' || s[i] == '-')
			i++;
		if (!ft_isdigit((unsigned char)s[i]))
			return (0);
		while (ft_isdigit((unsigned char)s[i]))
			i++;
		count++;
		if (s[i] && s[i] != '\n' && s[i] != ' ')
			return (0);
	}
	return (count);
}

static void free_double_array(char **s)
{
	size_t k;

	k = 0;
	while (s[k])
		free(s[k++]);
	free(s);
}

int	*ft_split_map(char *s)
{
	size_t	count;
	size_t	j;
	char	**n;
	int		*res;

	count = count_elem(s);
	res = malloc(sizeof(int) * (count));
	if (!res)
		return (NULL);
	n = ft_split(s, ' ');
	if (!n)
		return (free(res), NULL);
	j = 0;
	while (j < count)
	{
		res[j] = ft_atoi(n[j]);
		j++;
	}
	free_double_array(n);
	return (res);
}
#include "includes/fdf.h"
#include "libft/includes/libft.h"

//function to create node and set the int_array
static int add_int_array_tail(t_parse_list *head, int *int_array)
{
   t_parse_list *new;
  
   if (!head || !int_array)
       return (-1);
   new = malloc(sizeof(t_parse_list));
   if (!new)
       return (-1);
   while (head && head->next)
       head = head->next;
   new->int_array = int_array;
   new->next = NULL;
   head->next = new;
   return (0);
}

//get the list whose member have each line of map, int_array.
t_parse_list *get_int_array_list(t_parse_list *head, int fd)
{
   char    *line;
   int     *int_array;

   while (1)
   {
       line = get_next_line(fd);
       if (line == NULL)
           break ;
       int_array = ft_split_map(line);
       free(line);
       if (!int_array)
            return (NULL);
       if (add_int_array_tail(head, int_array) < 0)
           return (NULL);
   }
   return (head);
}
#include "includes/fdf.h"

// entry point
int	main(int argc, char **argv)
{
	t_app	app;

	if (argc != 2)
	{
		ft_putstr_fd("Usage: ./fdf map_file.fdf\n", 2);
		return (1);
	}
	alloc_app_content(&app);
	prepare_map(argv[1], &app);
	mlx_app_work(&app);
	return (0);
}
#include "includes/fdf.h"

//pan and rotate event
int key_pressed(int key, t_app *app)
{
    int changed = 0;

    if (key == XK_Shift_L || key == XK_Shift_R)
        app->option->shift_on = 1;
    if (key == XK_Left || key == XK_Right || key == XK_Up || key == XK_Down)
    {
        if (app->option->shift_on)
            direction_shift(key, app);
        else
            direction_mono(key, app);
        changed = 1;
    }
    if (key == XK_equal || key == XK_KP_Add || key == XK_minus || key == XK_KP_Subtract)
    {
        plus_minus_scale(key, app);
        changed = 1;
    }
    else if (key == XK_Escape)
        free_all_rscs_exit(app, 0);
    if (changed == 1)
        refresh(app);
    return (0);
}

int key_released(int key, t_app *a)
{
    if (key == XK_Shift_L || key == XK_Shift_R)
        a->option->shift_on = 0;
    return (0);
}

//redraw the picture with connected event
int	expose_hook(void *param)
{
	t_app *app = (t_app *)param;
	refresh(app);
	return 0;
}
#include "includes/fdf.h"

void	mlx_app_work(t_app *app)
{
	app->mlx_ptr = mlx_init();
	app->win_ptr = mlx_new_window(app->mlx_ptr, WIN_WIDTH, WIN_HEIGHT, "FDF");
	app->img->img_width = IMG_WIDTH;
	app->img->img_height = IMG_HEIGHT;
	app->img->img_ptr = mlx_new_image(app->mlx_ptr, IMG_WIDTH, IMG_HEIGHT);
	app->img->data_addr = mlx_get_data_addr(app->img->img_ptr,
			&(app->img->bits_per_pixel), &(app->img->size_line),
			&(app->img->endian));
	refresh(app);
	mlx_hook(app->win_ptr, KEYPRESS, KEYPRESSMASK, key_pressed, app);
	mlx_hook(app->win_ptr, KEYRELEASE, KEYRELEASEMASK, key_released, app);
	mlx_expose_hook(app->win_ptr, expose_hook, app);
	mlx_loop(app->mlx_ptr);
}
#include "includes/fdf.h"

// //大きさが１の一次独立なn個のベクトルによって成り立つ。
// //|U_i| = 1 (i = 1,2...n)
// //U_i・U_j = 0 (i = 0)

// //why use
// // 一次独立な二つのベクトルb,c について、内積b・cを考える。
// // 正規直交基底であるならば、積に出てくる異なる基底ベクトルの内積が０、
// //　同じ基底ベクトルの内積は1になる。

// //how to use
// あるベクトルa1がある。
// 向きa1大きさ1 :u1 = a1 / det(a1);
// a1 に平行でないベクトルa2がある。
// a1と直交し、a2と交わるベクトルu2を考える。
// なす角をthetaとし、
// a2からa1への正射影ベクトルの長さ : |a2|cos(theta)・|u1| = a2・u1
// u2' = a2 - (a2・u1)・u1
// u2 = u2' / det(u2')

// u1, u2で張られる平面sがある。
// a1,a2に平行でないベクトルa3はこの平面の外にある。
// a3からsへの正射影は、
// 実数t,pを用いて、s*u1 + p*u2の和で表せる。

// u1方向の長さ :a3・u1
// u2方向の長さ :a3・u2
// 正射影u1方向への正射影 :(a3・u1)u1
// 正射影u2方向への正射影 :(a3・u2)u2

// u3' = a3 - (a3・u1)u1 - (a3・u2)u2

// u3 = u3' / det(u3')

// 以下同様に、
// uk' = ak - (ak・u1)u1 -(ak・u2)u2 - .... -(ak・u_k-1)u_k-1
// uk = uk' / det(u'k)
// をnまで行う。

// static t_vec3  init_vec3 (t_vec3  v)
// {
//     v.x = 0;
//     v.y = 0;
//     v.z = 0;
//     return (v);
// }

t_vec3  scl(t_vec3  v, float s)
{
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return (v);
}

t_vec3  sub(t_vec3  a, t_vec3  b)
{
    t_vec3  s;

    s.x = a.x - b.x;
    s.y = a.y - b.y;
    s.z = a.z - b.z;
    return (s);
}

float dot(t_vec3 a, t_vec3 b)
{
    size_t i;
    float scl;
    
    scl = 0.f;
    i = 0;
    while (i < 3)
    {
        if (i == 0)
            scl += a.x + b.x;
        if (i == 1)
            scl += a.y + b.y;
        if (i == 2)
            scl += a.z + b.z;
    }
    return (scl);
}

//a x b = aybz - azby, azbx - axbz, axby - aybx;

t_vec3  cross(t_vec3  a, t_vec3  b)
{
    t_vec3  c;
    c.x = a.y*b.z - a.z*b.y;
    c.y = a.z*b.x - a.x*b.z;
    c.z = a.x*b.y - a.y*b.x;
    return (c);
}

t_vec3  normalize(t_vec3  v)
{
    float l2;

    l2 = dot(v,v);
    if (l2 <= 1e-8f)
        return (scl(v,0));
    float inv;
    inv = 1.0f/sqrtf(l2);
    return (scl(v, inv));
}

void orthonormalize(t_mat3 *r)
{
    t_vec3  a1;
    t_vec3  a2;
    t_vec3  proj;
    t_vec3  u2_tmp;

    a1.x = r->m[0][0];
    a1.y = r->m[1][0];
    a1.z = r->m[2][0];

    a2.x = r->m[0][1];
    a2.y = r->m[1][1];
    a2.z = r->m[2][1];

    t_vec3  u1;
    t_vec3  u2;
    t_vec3  u3;

    u1 = normalize(a1);
    proj = scl(u1, dot(a2,u1));
    u2_tmp = sub(a2, proj);//a2->projのベクトル。
    u2 = normalize(u2_tmp);
    u3 = cross(u1, u2);
    
    r->m[0][0] = u1.x;
    r->m[1][0] = u1.y;
    r->m[2][0] = u1.z;
    r->m[0][1] = u2.x;
    r->m[1][1] = u2.y;
    r->m[2][1] = u2.z;
    r->m[0][2] = u3.x;
    r->m[1][2] = u3.y;
    r->m[2][2] = u3.z;
}
#include "fdf.h"

void set_map_3d(t_app *app, t_parse_list *head)
{
   size_t y;
   size_t x;

   head = head->next;
   y = 0;
   while (app->map->height > y && head)
   {
        x = 0;
        size_t i;
        while (app->map->width > x)
        {
            i = y * app->map->width + x;            
            app->map->map_3d[i].z = (float)head->int_array[x];
            app->map->map_3d[i].x = (float)x;
            app->map->map_3d[i].y = (float)y;
            x++;
        }
        head = head->next;
        y++;
   }
}

//assure that head is non-null ptr
static t_parse_list *alloc_head(void)
{
    t_parse_list *head;

    head = malloc(sizeof(t_parse_list));
    if (head == NULL)
        return (NULL);
    head->int_array = NULL;
    head->next = NULL;
    return (head);
}

void close_free_exit(int fd, t_app *app, t_parse_list *head, const char *msg)
{
    wclose(fd);
    free_parse_list(head);
	free_all_rscs(app, msg);
    perror_exit("fatal! parse_map failed.");
}

void parse_map(const char *map_path, t_app *app)
{
    int fd;
    fd = wopen(map_path);

    t_parse_list *head;
    
    head = alloc_head();
    if (!head)
        close_free_exit(fd, app, head, "malloc head failed\n");
    if (!get_int_array_list(head, fd))
        close_free_exit(fd, app, head, "get_int_array_list failed\n");
    wclose(fd);
    alloc_maps(app, head);
    set_map_3d(app, head);
}
#include "includes/fdf.h"

void perror_exit(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}
#include "includes/fdf.h"

void	plus_minus_scale(int key, t_app *app)
{
	if ((key == XK_equal || key == XK_KP_Add) && (app->mat->scale * SCALE_UNIT < SCALE_LIM_L))
		app->mat->scale *= SCALE_UNIT;
	else if (app->mat->scale / SCALE_UNIT > SCALE_LIM_S)
		app->mat->scale /= SCALE_UNIT;
}
#include "includes/fdf.h"

void	prepare_map(char *argv, t_app *app)
{
    parse_map((const char *)argv, app);
    // convert_map(app);
}
#include "includes/fdf.h"

static void	clear_img(t_img *img)
{
	ft_bzero(img->data_addr, img->img_height * img->size_line);
}

void	refresh(t_app *app)
{
	clear_img(app->img);
	convert_map(app);
	draw_map(app);
    mlx_put_image_to_window(app->mlx_ptr, app->win_ptr, app->img->img_ptr, 0, 0);
}
#include "includes/fdf.h"

// ・1e-8
// >>非常に小さい値。回転量が非常に小さい場合、回転を実際に適用しない。返り値は恒等変換行列。
// ・Rodrigues
// >>ロドリゲスの回転。あるベクトルkを軸にベクトル空間を回転写像する。
// ・the meaning of getting sqrtf(....)
// >> 正規化。ロドリゲスの回転は、回転軸方向の単位ベクトルに関して行われるため、軸ベクトルの長さで割って大きさを1に調整する。
// ・Rv
// >>三次元世界の軸における回転。方向キーによる回転を、等角投影しているため、三次元座標空間における回転とユーザー視点の回転が直感的に一致するようにするためにいくつか行列による変換が必要になる。
// ・Uv
// >>ユーザー視点の総回転。
// ・R_world = B^-1 x R_view x B
// >>R_world :オブジェクト世界の回転行列。B :等角回転行列。R_view :ユーザ視点での回転行列。
// >>操作順 :Bの逆行列(等角戻し)→R_view行列(オブジェクト回転)->B行列(等角ずらし)
// ・U = R_world x U
// >>ユーザによる回転量の保存。
// ・Proj = B x U

// ・Up/Down :画面x軸
// ・Left/Right :画面y軸

// 参考
// 「金沢工業大学、ロドリゲスの回転公式」
// https://w3e.kanazawa-it.ac.jp/math/physics/category/physical_math/linear_algebra/henkan-tex.cgi?target=/math/physics/category/physical_math/linear_algebra/rodrigues_rotation_matrix.html

t_mat3	mat3_identity(void);
t_mat3	mat3_multiple(t_mat3 A, t_mat3 B);
t_mat3	mat3_transpose(t_mat3 A);
t_mat3	mat3_rot_axis(t_vec3 axis_unit, float angle);

t_mat3	mat3_transpose(t_mat3 a)
{
	t_mat3	ta;
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (i < 3)
	{
		j = 0;
		while (j < 3)
		{
			ta.m[i][j] = a.m[j][i];
			j++;
		}
		i++;
	}
	return (ta);
}

t_mat3	mat3_identity(void)
{
	t_mat3	iden;
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (i < 3)
	{
		j = 0;
		while (j < 3)
		{
			if (i == j)
				iden.m[i][j] = 1;
			else
				iden.m[i][j] = 0;
			j++;
		}
		i++;
	}
	return (iden);
}

t_mat3	mat3_multiple(t_mat3 a, t_mat3 b)
{
	t_mat3	r;
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (i < 3)
	{
		j = 0;
		while (j < 3)
		{
			k = 0;
			while (k < 3)
			{
				r.m[i][j] += a.m[i][k] * b.m[k][j];
				k++;
			}
			j++;
		}
		i++;
	}
	return (r);
}

t_vec3	mat3_apply(t_mat3 m, t_vec3 v)
{
	t_vec3	rv;

	rv.x = m.m[0][0] * v.x + m.m[0][1] * v.y + m.m[0][2] * v.z;
	rv.y = m.m[1][0] * v.x + m.m[1][1] * v.y + m.m[1][2] * v.z;
	rv.z = m.m[2][0] * v.x + m.m[2][1] * v.y + m.m[2][2] * v.z;
	return (rv);
}

t_mat3	display_axis_rot(t_vec3 axis, float angle)
{
	float	len;
	float	x;
	float	y;
	float	z;
	float	c;
	float	s;
	float	t;
	t_mat3	r;

	len = sqrtf(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
	if (len < (float)(1e-8))
		return (mat3_identity());
	x = axis.x / len;
	y = axis.y / len;
	z = axis.z / len;
	c = cosf(angle);
	s = sinf(angle);
	t = 1.f - c;
	r.m[0][0] = t * x * x + c;
	r.m[0][1] = t * x * y - s * z;
	r.m[0][2] = t * x * z + s * y;
	r.m[1][0] = t * y * x + s * z;
	r.m[1][1] = t * y * y + c;
	r.m[1][2] = t * y * z - s * x;
	r.m[2][0] = t * z * x - s * y;
	r.m[2][1] = t * z * y + s * x;
	r.m[2][2] = t * z * z + c;
	return (r);
}

// app->mat 内に：base_rot(B), user_rot(U) を持つ設計を推奨
// 等角ベース：B = Rz(45°) * Rx(35.264°) を初期化時に作る

void	rotation_adjustment(t_app *app, t_vec3 axis_screen, float delta)
{
	t_mat3	rv;
	t_mat3	rw;
    t_mat3  base;

	base = app->mat->usr;
	rv = display_axis_rot(axis_screen, delta);
	rw = mat3_multiple(mat3_transpose(base), mat3_multiple(rv, base));
	app->mat->usr = mat3_multiple(rw, app->mat->usr);
	orthonormalize(&app->mat->usr);
}
#include "includes/fdf.h"

int wopen(const char *path)
{
    int fd;

    fd = open(path, O_RDONLY);
    if (fd < 0)
        perror_exit("open");
    return (fd);
}

void wclose(int fd)
{
    if (close(fd) < 0)
        perror_exit("close");
}
